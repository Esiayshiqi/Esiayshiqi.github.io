<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>高低错落上升烟花</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        .speed-control {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
            touch-action: manipulation;
        }
        .speed-options {
            position: fixed;
            right: 20px;
            bottom: 70px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 99;
        }
        .speed-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            touch-action: manipulation;
        }
        .speed-option.active {
            background: #fff;
            color: #000;
        }
    </style>
</head>
<body>
    <canvas id="fireworks"></canvas>
    <div class="speed-control">×1</div>
    <div class="speed-options">
        <div class="speed-option active" data-speed="1">×1</div>
        <div class="speed-option" data-speed="2">×2</div>
        <div class="speed-option" data-speed="4">×4</div>
        <div class="speed-option" data-speed="6">×6</div>
        <div class="speed-option" data-speed="8">×8</div>
    </div>

    <script>
        const canvas = document.getElementById('fireworks');
        const ctx = canvas.getContext('2d');
        const speedControl = document.querySelector('.speed-control');
        const speedOptions = document.querySelector('.speed-options');
        const speedButtons = document.querySelectorAll('.speed-option');
        let width, height;
        let fireworks = [];
        let particles = [];
        let lastTime = 0;
        let isActive = false;
        let usedHues = [];
        const HUE_INTERVAL = 30;
        let launchSpeedMultiplier = 1;

        // 屏幕适配
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        resize();
        window.addEventListener('resize', resize);

        // 粒子类
        class Particle {
            constructor(x, y, baseHue, type) {
                this.x = x;
                this.y = y;
                this.baseHue = baseHue;
                this.type = type;
                this.life = 1;
                this.alpha = 1;
                this.size = 0.8 + Math.random() * 2.2;
                this.gravity = 0.03 + Math.random() * 0.05;
                this.friction = 0.94 + Math.random() * 0.03;
                this.wind = (Math.random() - 0.5) * 0.08;

                this.hue = (baseHue + (Math.random() - 0.5) * 10) % 360;
                this.lightness = 60 + Math.random() * 20;

                const angle = Math.random() * Math.PI * 2;
                let speed = 2 + Math.random() * 4;
                if (type === 1) speed *= 1.5;
                if (type === 3) speed *= 0.8;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                if (type === 2) {
                    this.trail = [];
                    this.trailLength = 5 + Math.floor(Math.random() * 5);
                }
            }

            update(deltaTime) {
                const factor = deltaTime / 16;
                this.vx = (this.vx + this.wind) * this.friction;
                this.vy = (this.vy + this.gravity) * this.friction;
                this.x += this.vx * factor;
                this.y += this.vy * factor;

                this.life -= (0.012 * factor) + (Math.abs(this.vy) * 0.0008);
                this.alpha = Math.min(this.life * 1.2, 1);

                if (this.type === 2) {
                    this.trail.unshift({x: this.x, y: this.y, alpha: this.alpha * 0.6});
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
            }

            draw() {
                if (this.alpha <= 0) return;
                ctx.globalAlpha = this.alpha;
                const color = `hsla(${this.hue}, 90%, ${this.lightness}%, ${this.alpha})`;

                switch (this.type) {
                    case 1:
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = `hsla(${this.hue}, 100%, 90%, ${this.alpha})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * 0.6, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2:
                        this.trail.forEach((p, i) => {
                            const trailAlpha = p.alpha * (1 - i / this.trailLength);
                            ctx.fillStyle = `hsla(${this.hue}, 90%, ${this.lightness + 10}%, ${trailAlpha})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, this.size * (1 - i / this.trailLength), 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 3:
                        ctx.fillStyle = color;
                        this.drawStar(this.x, this.y, 6, this.size, this.size * 0.4);
                        break;
                    default:
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            drawStar(cx, cy, points, outerR, innerR) {
                let rot = Math.PI / 2 * 3;
                let x = cx;
                let y = cy;
                const step = Math.PI / points;
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerR);
                for (let i = 0; i < points; i++) {
                    x = cx + Math.cos(rot) * outerR;
                    y = cy + Math.sin(rot) * outerR;
                    ctx.lineTo(x, y);
                    rot += step;
                    x = cx + Math.cos(rot) * innerR;
                    y = cy + Math.sin(rot) * innerR;
                    ctx.lineTo(x, y);
                    rot += step;
                }
                ctx.lineTo(cx, cy - outerR);
                ctx.closePath();
                ctx.fill();
            }

            isAlive() {
                return this.life > 0;
            }
        }

        // 烟花弹类（仅保留上升方向，高度差异化）
        class Firework {
            constructor(x = null, y = null) {
                this.isUp = true; // 强制仅上升
                this.x = x !== null ? x : (Math.random() * width * 0.9 + width * 0.05);
                this.y = y !== null ? y : height; // 从底部或触碰点上升
                // 核心：高度差异化（分三档高度，随机选择）
                const heightLevel = Math.random();
                if (heightLevel < 0.3) {
                    // 低高度（屏幕1/4 - 1/3处）
                    this.targetY = Math.random() * (height * 0.3 - height * 0.25) + height * 0.15;
                } else if (heightLevel < 0.7) {
                    // 中高度（屏幕1/3 - 1/2处）
                    this.targetY = Math.random() * (height * 0.5 - height * 0.3) + height * 0.3;
                } else {
                    // 高高度（屏幕1/2 - 2/3处）
                    this.targetY = Math.random() * (height * 0.65 - height * 0.5) + height * 0.5;
                }
                // 触碰生成的烟花高度自适应
                if (y !== null) {
                    this.targetY = this.y - (50 + Math.random() * 200); // 从触碰点向上50-250px爆炸
                    // 确保不超出屏幕顶部
                    this.targetY = Math.max(this.targetY, height * 0.1);
                }
                this.hue = this.getUniqueHue();
                this.baseSpeed = -7 - Math.random() * 3; // 上升基础速度
                this.trail = [];
                this.explodeType = Math.floor(Math.random() * 5);
                this.isManual = x !== null;

                if (usedHues.length > 12) {
                    usedHues.shift();
                }
            }

            getUniqueHue() {
                let newHue;
                let isUnique = false;

                for (let i = 0; i < 10; i++) {
                    newHue = Math.random() * 360;
                    isUnique = usedHues.every(hue => {
                        const diff = Math.abs(newHue - hue);
                        return diff >= HUE_INTERVAL || diff <= (360 - HUE_INTERVAL);
                    });
                    if (isUnique) break;
                }

                if (!isUnique) {
                    usedHues.shift();
                }

                usedHues.push(newHue);
                return newHue;
            }

            update(deltaTime) {
                const baseFactor = deltaTime / 16;
                const launchFactor = baseFactor * launchSpeedMultiplier;
                
                this.y += this.baseSpeed * launchFactor;
                this.baseSpeed += 0.12 * launchFactor; // 上升加速度

                if (Math.random() < 0.7) {
                    this.trail.push({
                        x: this.x, 
                        y: this.y, 
                        alpha: 0.6,
                        size: 2 - this.trail.length * 0.1
                    });
                }
                if (this.trail.length > 12) this.trail.shift();
                
                this.trail.forEach((p, i) => {
                    p.alpha *= 0.82;
                    ctx.fillStyle = `hsla(${this.hue}, 90%, 70%, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.fillStyle = `hsl(${this.hue}, 100%, 80%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
                ctx.fill();

                // 上升到目标高度爆炸
                return this.y <= this.targetY || this.baseSpeed >= -1;
            }

            explode() {
                const particles = [];
                const baseCount = 100 + Math.random() * 100;

                switch (this.explodeType) {
                    case 0:
                        for (let i = 0; i < baseCount; i++) {
                            const type = i % 5 === 0 ? 1 : 0;
                            particles.push(new Particle(this.x, this.y, this.hue, type));
                        }
                        break;
                    case 1:
                        const rings = 3;
                        for (let r = 0; r < rings; r++) {
                            const radius = (r + 1) * 0.8;
                            const count = baseCount / rings;
                            for (let i = 0; i < count; i++) {
                                const angle = (i / count) * Math.PI * 2;
                                const p = new Particle(this.x, this.y, this.hue, 0);
                                p.vx = Math.cos(angle) * (2 + radius);
                                p.vy = Math.sin(angle) * (2 + radius);
                                particles.push(p);
                            }
                        }
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 1));
                        }
                        break;
                    case 2:
                        const points = 8 + Math.floor(Math.random() * 4);
                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * Math.PI * 2;
                            for (let j = 0; j < 30; j++) {
                                const p = new Particle(this.x, this.y, this.hue, 3);
                                const spread = 0.4;
                                const realAngle = angle + (Math.random() - 0.5) * spread;
                                const speed = 2 + Math.random() * 3 - j * 0.08;
                                p.vx = Math.cos(realAngle) * speed;
                                p.vy = Math.sin(realAngle) * speed;
                                particles.push(p);
                            }
                        }
                        break;
                    case 3:
                        for (let i = 0; i < baseCount * 1.2; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 2));
                        }
                        break;
                    case 4:
                        for (let i = 0; i < baseCount * 0.3; i++) {
                            const angle = (i / (baseCount * 0.3)) * Math.PI * 2;
                            const p = new Particle(this.x, this.y, this.hue, 0);
                            p.vx = Math.cos(angle) * (3 + Math.random() * 2);
                            p.vy = Math.sin(angle) * (3 + Math.random() * 2);
                            particles.push(p);
                        }
                        for (let i = 0; i < baseCount * 0.4; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 3));
                        }
                        for (let i = 0; i < 30; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 1));
                        }
                        for (let i = 0; i < baseCount * 0.3; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 2));
                        }
                        break;
                }

                return particles;
            }
        }

        // 动画循环
        function animate(timestamp) {
            if (!isActive) return;
            const deltaTime = timestamp - lastTime || 16;
            lastTime = timestamp;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.06)';
            ctx.fillRect(0, 0, width, height);

            for (let i = fireworks.length - 1; i >= 0; i--) {
                const firework = fireworks[i];
                const exploded = firework.update(deltaTime);
                if (exploded) {
                    particles = particles.concat(firework.explode());
                    fireworks.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update(deltaTime);
                p.draw();
                if (!p.isAlive()) {
                    particles.splice(i, 1);
                }
            }

            // 自动生成烟花（仅上升）
            const spawnProbability = 0.025 * Math.min(launchSpeedMultiplier, 4);
            if (fireworks.length < 10 && Math.random() < spawnProbability) {
                fireworks.push(new Firework());
            }

            requestAnimationFrame(animate);
        }

        // 触碰位置生成烟花（仅上升）
        function triggerFireworkAt(x, y) {
            if (!isActive) {
                isActive = true;
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
            fireworks.push(new Firework(x, y)); // 仅生成上升烟花
        }

        // 速度控制
        speedControl.addEventListener('click', () => {
            speedOptions.style.display = speedOptions.style.display === 'flex' ? 'none' : 'flex';
        });

        speedButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const speed = parseInt(btn.dataset.speed);
                launchSpeedMultiplier = speed;
                speedButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                speedControl.textContent = `×${speed}`;
                speedOptions.style.display = 'none';
            });
        });

        document.addEventListener('click', (e) => {
            if (!speedControl.contains(e.target) && !speedOptions.contains(e.target)) {
                speedOptions.style.display = 'none';
            }
        });

        // 触摸/点击交互
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            triggerFireworkAt(x, y);
        }, { passive: false });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            triggerFireworkAt(x, y);
        });
    </script>
</body>
</html>