<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>超高空烟花秀</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; }
        .speed-control {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            z-index: 100;
            touch-action: manipulation;
        }
        .speed-options {
            position: fixed;
            right: 20px;
            bottom: 70px;
            display: none;
            flex-direction: column;
            gap: 10px;
            z-index: 99;
        }
        .speed-option {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            cursor: pointer;
            touch-action: manipulation;
        }
        .speed-option.active {
            background: #fff;
            color: #000;
        }
    </style>
</head>
<body>
    <canvas id="fireworks"></canvas>
    <div class="speed-control">×1</div>
    <div class="speed-options">
        <div class="speed-option active" data-speed="1">×1</div>
        <div class="speed-option" data-speed="2">×2</div>
        <div class="speed-option" data-speed="4">×4</div>
        <div class="speed-option" data-speed="6">×6</div>
        <div class="speed-option" data-speed="8">×8</div>
    </div>

    <script>
        const canvas = document.getElementById('fireworks');
        const ctx = canvas.getContext('2d');
        const speedControl = document.querySelector('.speed-control');
        const speedOptions = document.querySelector('.speed-options');
        const speedButtons = document.querySelectorAll('.speed-option');
        let width, height;
        let fireworks = [];
        let particles = [];
        let lastTime = 0;
        let isActive = false;
        let usedHues = [];
        const HUE_INTERVAL = 30;
        let launchSpeedMultiplier = 1;
        // 性能控制参数
        const MAX_FIREWORKS = 8;
        const MAX_PARTICLES = 1500;
        const PARTICLE_SIZE_SCALE = 0.9;

        // 屏幕适配
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            const dpr = Math.min(window.devicePixelRatio || 1, 2);
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = `${width}px`;
            canvas.style.height = `${height}px`;
        }
        resize();
        window.addEventListener('resize', resize);

        // 粒子类（保持性能优化）
        class Particle {
            constructor(x, y, baseHue, type) {
                this.x = x;
                this.y = y;
                this.baseHue = baseHue;
                this.type = type;
                this.life = 1;
                this.alpha = 1;
                this.size = (0.6 + Math.random() * 1.8) * PARTICLE_SIZE_SCALE;
                this.gravity = 0.03 + Math.random() * 0.04;
                this.friction = 0.94 + Math.random() * 0.03;
                this.wind = (Math.random() - 0.5) * 0.06;

                this.hue = (baseHue + (Math.random() - 0.5) * 10) % 360;
                this.lightness = 60 + Math.random() * 20;

                const angle = Math.random() * Math.PI * 2;
                let speed = 2 + Math.random() * 3;
                if (type === 1) speed *= 1.4;
                if (type === 3) speed *= 0.7;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                if (type === 2) {
                    this.trail = [];
                    this.trailLength = 3 + Math.floor(Math.random() * 3);
                }
            }

            update(deltaTime) {
                const factor = deltaTime / 16;
                this.vx = (this.vx + this.wind) * this.friction;
                this.vy = (this.vy + this.gravity) * this.friction;
                this.x += this.vx * factor;
                this.y += this.vy * factor;

                this.life -= 0.015 * factor;
                this.alpha = Math.min(this.life, 1);

                if (this.type === 2 && this.alpha > 0.3) {
                    this.trail.unshift({x: this.x, y: this.y, alpha: this.alpha * 0.6});
                    if (this.trail.length > this.trailLength) this.trail.pop();
                }
            }

            draw() {
                if (this.alpha <= 0.1) return;
                ctx.globalAlpha = this.alpha;
                const color = `hsla(${this.hue}, 90%, ${this.lightness}%, ${this.alpha})`;

                switch (this.type) {
                    case 1:
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * 1.3, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.fillStyle = `hsla(${this.hue}, 100%, 90%, ${this.alpha})`;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size * 0.5, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 2:
                        this.trail.forEach((p, i) => {
                            const trailAlpha = p.alpha * (1 - i / this.trailLength);
                            if (trailAlpha < 0.1) return;
                            ctx.fillStyle = `hsla(${this.hue}, 90%, ${this.lightness + 10}%, ${trailAlpha})`;
                            ctx.beginPath();
                            ctx.arc(p.x, p.y, this.size * (1 - i / this.trailLength), 0, Math.PI * 2);
                            ctx.fill();
                        });
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                        break;
                    case 3:
                        ctx.fillStyle = color;
                        this.drawStar(this.x, this.y, 5, this.size, this.size * 0.4);
                        break;
                    default:
                        ctx.fillStyle = color;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                        ctx.fill();
                }
                ctx.globalAlpha = 1;
            }

            drawStar(cx, cy, points, outerR, innerR) {
                let rot = Math.PI / 2 * 3;
                ctx.beginPath();
                ctx.moveTo(cx, cy - outerR);
                for (let i = 0; i < points; i++) {
                    const x = cx + Math.cos(rot) * outerR;
                    const y = cy + Math.sin(rot) * outerR;
                    ctx.lineTo(x, y);
                    rot += Math.PI / points;
                    const x2 = cx + Math.cos(rot) * innerR;
                    const y2 = cy + Math.sin(rot) * innerR;
                    ctx.lineTo(x2, y2);
                    rot += Math.PI / points;
                }
                ctx.closePath();
                ctx.fill();
            }

            isAlive() {
                return this.life > 0;
            }
        }

        // 烟花弹类（核心：高度提升1倍）
        class Firework {
            constructor(x = null, y = null) {
                this.isUp = true;
                this.x = x !== null ? x : (Math.random() * width * 0.9 + width * 0.05);
                this.y = y !== null ? y : height;
                // 核心改动：高度提升1倍（基于上一版再翻倍，贴近屏幕顶部）
                const heightLevel = Math.random();
                if (heightLevel < 0.3) {
                    // 低高度：原25%-45% → 提升至40%-60%（翻倍）
                    this.targetY = Math.random() * (height * 0.6 - height * 0.4) + height * 0.4;
                } else if (heightLevel < 0.7) {
                    // 中高度：原45%-70% → 提升至60%-80%（翻倍）
                    this.targetY = Math.random() * (height * 0.8 - height * 0.6) + height * 0.6;
                } else {
                    // 高高度：原70%-85% → 提升至80%-90%（接近屏幕顶部）
                    this.targetY = Math.random() * (height * 0.9 - height * 0.8) + height * 0.8;
                }
                // 触摸生成的烟花同步提升高度
                if (y !== null) {
                    this.targetY = this.y - (160 + Math.random() * 600); // 爆炸点上移1倍
                    this.targetY = Math.max(this.targetY, height * 0.4); // 最低不低于40%
                }
                this.hue = this.getUniqueHue();
                this.baseSpeed = -8 - Math.random() * 3; // 增加上升初速度，适应更高高度
                this.trail = [];
                this.explodeType = Math.floor(Math.random() * 5);
                this.isManual = x !== null;

                if (usedHues.length > 10) {
                    usedHues.shift();
                }
            }

            getUniqueHue() {
                let newHue;
                let isUnique = false;
                for (let i = 0; i < 8; i++) {
                    newHue = Math.random() * 360;
                    isUnique = usedHues.every(hue => {
                        const diff = Math.abs(newHue - hue);
                        return diff >= HUE_INTERVAL || diff <= (360 - HUE_INTERVAL);
                    });
                    if (isUnique) break;
                }
                if (!isUnique) {
                    usedHues.shift();
                }
                usedHues.push(newHue);
                return newHue;
            }

            update(deltaTime) {
                const baseFactor = deltaTime / 16;
                const launchFactor = baseFactor * launchSpeedMultiplier;
                
                this.y += this.baseSpeed * launchFactor;
                this.baseSpeed += 0.13 * launchFactor; // 增加加速度，确保能到达更高高度
                
                if (Math.random() < 0.6 && this.trail.length < 10) {
                    this.trail.push({
                        x: this.x, 
                        y: this.y, 
                        alpha: 0.6,
                        size: 1.8 - this.trail.length * 0.1
                    });
                }
                if (this.trail.length > 10) this.trail.shift();
                
                this.trail.forEach((p, i) => {
                    p.alpha *= 0.8;
                    if (p.alpha < 0.1) return;
                    ctx.fillStyle = `hsla(${this.hue}, 90%, 70%, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.fillStyle = `hsl(${this.hue}, 100%, 80%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2.2, 0, Math.PI * 2);
                ctx.fill();

                return this.y <= this.targetY || this.baseSpeed >= -1;
            }

            explode() {
                const particles = [];
                const baseCount = 80 + Math.random() * 70;

                switch (this.explodeType) {
                    case 0:
                        for (let i = 0; i < baseCount; i++) {
                            const type = i % 6 === 0 ? 1 : 0;
                            particles.push(new Particle(this.x, this.y, this.hue, type));
                        }
                        break;
                    case 1:
                        const rings = 2;
                        for (let r = 0; r < rings; r++) {
                            const radius = (r + 1) * 0.8;
                            const count = baseCount / rings;
                            for (let i = 0; i < count; i++) {
                                const angle = (i / count) * Math.PI * 2;
                                const p = new Particle(this.x, this.y, this.hue, 0);
                                p.vx = Math.cos(angle) * (2 + radius);
                                p.vy = Math.sin(angle) * (2 + radius);
                                particles.push(p);
                            }
                        }
                        for (let i = 0; i < 15; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 1));
                        }
                        break;
                    case 2:
                        const points = 6 + Math.floor(Math.random() * 3);
                        for (let i = 0; i < points; i++) {
                            const angle = (i / points) * Math.PI * 2;
                            for (let j = 0; j < 25; j++) {
                                const p = new Particle(this.x, this.y, this.hue, 3);
                                const spread = 0.4;
                                const realAngle = angle + (Math.random() - 0.5) * spread;
                                const speed = 2 + Math.random() * 2.5 - j * 0.08;
                                p.vx = Math.cos(realAngle) * speed;
                                p.vy = Math.sin(realAngle) * speed;
                                particles.push(p);
                            }
                        }
                        break;
                    case 3:
                        for (let i = 0; i < baseCount * 1.1; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 2));
                        }
                        break;
                    case 4:
                        for (let i = 0; i < baseCount * 0.2; i++) {
                            const angle = (i / (baseCount * 0.2)) * Math.PI * 2;
                            const p = new Particle(this.x, this.y, this.hue, 0);
                            p.vx = Math.cos(angle) * (3 + Math.random() * 2);
                            p.vy = Math.sin(angle) * (3 + Math.random() * 2);
                            particles.push(p);
                        }
                        for (let i = 0; i < baseCount * 0.3; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 3));
                        }
                        for (let i = 0; i < 20; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 1));
                        }
                        for (let i = 0; i < baseCount * 0.2; i++) {
                            particles.push(new Particle(this.x, this.y, this.hue, 2));
                        }
                        break;
                }

                return particles;
            }
        }

        // 动画循环
        function animate(timestamp) {
            if (!isActive) return;
            const deltaTime = timestamp - lastTime || 16;
            lastTime = timestamp;

            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, width, height);

            if (fireworks.length < MAX_FIREWORKS) {
                const spawnProbability = 0.02 * Math.min(launchSpeedMultiplier, 4);
                if (Math.random() < spawnProbability) {
                    fireworks.push(new Firework());
                }
            }

            for (let i = fireworks.length - 1; i >= 0; i--) {
                const firework = fireworks[i];
                const exploded = firework.update(deltaTime);
                if (exploded) {
                    if (particles.length < MAX_PARTICLES) {
                        particles = particles.concat(firework.explode());
                    }
                    fireworks.splice(i, 1);
                }
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update(deltaTime);
                p.draw();
                if (!p.isAlive() || particles.length > MAX_PARTICLES) {
                    particles.splice(i, 1);
                }
            }

            requestAnimationFrame(animate);
        }

        // 触碰交互
        function triggerFireworkAt(x, y) {
            if (!isActive) {
                isActive = true;
                lastTime = performance.now();
                requestAnimationFrame(animate);
            }
            if (fireworks.length < MAX_FIREWORKS - 1) {
                fireworks.push(new Firework(x, y));
            }
        }

        // 速度控制
        speedControl.addEventListener('click', () => {
            speedOptions.style.display = speedOptions.style.display === 'flex' ? 'none' : 'flex';
        });

        speedButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const speed = parseInt(btn.dataset.speed);
                launchSpeedMultiplier = speed;
                speedButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                speedControl.textContent = `×${speed}`;
                speedOptions.style.display = 'none';
            });
        });

        document.addEventListener('click', (e) => {
            if (!speedControl.contains(e.target) && !speedOptions.contains(e.target)) {
                speedOptions.style.display = 'none';
            }
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const rect = canvas.getBoundingClientRect();
            triggerFireworkAt(touch.clientX - rect.left, touch.clientY - rect.top);
        }, { passive: false });

        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            triggerFireworkAt(e.clientX - rect.left, e.clientY - rect.top);
        });
    </script>
</body>
</html>