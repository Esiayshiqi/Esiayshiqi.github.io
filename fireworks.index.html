<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>微信烟花秀</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; }
        canvas { display: block; }
        #tip { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; font-size: 16px; opacity: 0.8; }
    </style>
</head>
<body>
    <div id="tip">点击屏幕开始烟花表演</div>
    <canvas id="fireworks"></canvas>

    <script>
        const canvas = document.getElementById('fireworks');
        const ctx = canvas.getContext('2d');
        const tip = document.getElementById('tip');
        let width, height;
        let fireworks = [];
        let particles = [];
        let isRunning = false;

        // 适配微信屏幕
        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            const dpr = window.devicePixelRatio || 1; // 高清屏适配
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            ctx.scale(dpr, dpr);
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
        }
        resize();
        window.addEventListener('resize', resize);

        // 烟花粒子类
        class Particle {
            constructor(x, y, hue) {
                this.x = x;
                this.y = y;
                this.hue = hue;
                this.life = 1;
                this.alpha = 1;
                this.size = Math.random() * 2 + 1;
                // 随机速度和方向（模拟爆炸扩散）
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 2;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.gravity = 0.08; // 重力影响
                this.friction = 0.95; // 空气阻力
            }

            update() {
                this.vx *= this.friction;
                this.vy = (this.vy + this.gravity) * this.friction;
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02; // 生命周期衰减
                this.alpha = Math.min(this.life, 1);
            }

            draw() {
                if (this.alpha <= 0) return;
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = `hsl(${this.hue}, 100%, 60%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1;
            }
        }

        // 烟花发射类
        class Firework {
            constructor() {
                this.x = Math.random() * width * 0.8 + width * 0.1; // 限制发射范围
                this.y = height;
                this.targetY = Math.random() * height * 0.4 + height * 0.2; // 爆炸高度
                this.hue = Math.random() * 360; // 随机颜色
                this.vy = -8 - Math.random() * 4; // 上升速度
                this.trail = []; // 尾迹
            }

            update() {
                // 上升运动
                this.y += this.vy;
                this.vy += 0.15; // 上升减速（模拟重力）

                // 绘制尾迹
                this.trail.push({x: this.x, y: this.y, alpha: 0.6});
                if (this.trail.length > 15) this.trail.shift();
                this.trail.forEach((p, i) => {
                    p.alpha *= 0.85;
                    ctx.fillStyle = `hsla(${this.hue}, 100%, 60%, ${p.alpha})`;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 1.5 - i * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                });

                // 绘制烟花弹
                ctx.fillStyle = `hsl(${this.hue}, 100%, 70%)`;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 2.5, 0, Math.PI * 2);
                ctx.fill();

                // 判断是否到达爆炸点
                return this.y <= this.targetY || this.vy >= -1;
            }
        }

        // 爆炸效果
        function explode(x, y, hue) {
            const particleCount = 80 + Math.random() * 50; // 随机粒子数量
            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle(x, y, hue));
            }
        }

        // 主循环
        function loop() {
            if (!isRunning) return;
            
            // 绘制黑色半透明背景（保留轨迹）
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, width, height);

            // 更新烟花
            for (let i = fireworks.length - 1; i >= 0; i--) {
                const firework = fireworks[i];
                const exploded = firework.update();
                if (exploded) {
                    explode(firework.x, firework.y, firework.hue);
                    fireworks.splice(i, 1);
                }
            }

            // 更新粒子
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.draw();
                if (p.life <= 0) particles.splice(i, 1);
            }

            // 随机生成新烟花
            if (Math.random() < 0.02) {
                fireworks.push(new Firework());
            }

            requestAnimationFrame(loop);
        }

        // 微信需要用户交互才能启动动画
        function start() {
            if (!isRunning) {
                isRunning = true;
                tip.style.display = 'none';
                loop();
            }
        }

        // 监听触摸和点击事件
        canvas.addEventListener('touchstart', start);
        canvas.addEventListener('click', start);
    </script>
</body>
</html>